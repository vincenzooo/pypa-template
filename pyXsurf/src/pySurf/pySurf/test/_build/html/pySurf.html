<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pySurf package &mdash; userKov 1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="userKov 1 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pysurf-package">
<h1>pySurf package<a class="headerlink" href="#pysurf-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pySurf.FEA">
<span id="pysurf-fea-module"></span><h2>pySurf.FEA module<a class="headerlink" href="#module-pySurf.FEA" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.FEA.FEAreader1">
<code class="descclassname">pySurf.FEA.</code><code class="descname">FEAreader1</code><span class="sig-paren">(</span><em>FEAfile</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.FEA.FEAreader1" title="Permalink to this definition">¶</a></dt>
<dd><p>read V. Marquez files. Perform column shifting and knvert x returning result in operator coordinates
with all units in mm.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.FEA.plotFEA">
<code class="descclassname">pySurf.FEA.</code><code class="descname">plotFEA</code><span class="sig-paren">(</span><em>FEAfile</em>, <em>FEAreader</em>, <em>datafile=None</em>, <em>outname=None</em>, <em>markers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.FEA.plotFEA" title="Permalink to this definition">¶</a></dt>
<dd><p>read FEA and resample/rebin both points and FEA on the grid defined by steps, subtract gravity from pts
and plot and returns the corrected points. Simulation and data are also plotted if valid.
If datafile is not passed only simulation data are plotted and returned.
FEA reader is a function that accept a single argument FEAfile and return an array of points describing
changes in shape (x,y,dz).</p>
</dd></dl>

</div>
<div class="section" id="module-pySurf.PointCloud">
<span id="pysurf-pointcloud-module"></span><h2>pySurf.PointCloud module<a class="headerlink" href="#module-pySurf.PointCloud" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pySurf.PointCloud.Points">
<em class="property">class </em><code class="descclassname">pySurf.PointCloud.</code><code class="descname">Points</code><span class="sig-paren">(</span><em>filename=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Represent a set of points in a N-dimensional point cloud, defined as array in format (Npoints,Ndim).</p>
<dl class="method">
<dt id="pySurf.PointCloud.Points.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>xrange=None</em>, <em>yrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>crop a xyz points [Nx3], keeping only points inside xrange and yrange defined as (min,max).</p>
</dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter=''</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>xgrid=None</em>, <em>ygrid=None</em>, <em>shape=None</em>, <em>resample=True</em>, <em>scatter=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>resample xyz points [Nx3] to a grid whose axis xgrid and ygrid are given
and plot it. If resample is set to False x and y positions are considered only for range,
but they are not used to position the z values (it works if x and y are on an exact unrotated grid,
resampling is slower, but exact).</p>
</dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>resample points [Npoints x 3] on the points defined in positions [Mpoints x 2], or [Mpoints x 3]
(in this case 3rd column is ignored).
Return a [Nx x Ny , 3] vector of points. To get a (plottable) matrix of data use:
plt.imshow(rpoints[:,2].reshape(xgrid.size,ygrid.size)).</p>
</dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.resample_grid">
<code class="descname">resample_grid</code><span class="sig-paren">(</span><em>xgrid</em>, <em>ygrid</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.resample_grid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>xcrop=None</em>, <em>ycrop=None</em>, <em>mask=None</em>, <em>clip=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>return the rms of the selected points.</p>
</dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>center=(0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>returns rotated coordinates of 2D point(s) x ([Npoints x 2]) about a center with anticlockwise angle theta in rad.
If 3D points are passed, z coordinate is maintained.</p>
</dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>xgrid=None</em>, <em>ygrid=None</em>, <em>shape=None</em>, <em>matrix=False</em>, <em>fill_value=nan</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save points on a file. If matrix is true write in matrix form (in this case you have to
provide the values for axis). Otherwise write as points in columns.</p>
</dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.smooth_points">
<code class="descname">smooth_points</code><span class="sig-paren">(</span><em>xywidth</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.smooth_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.subtract_points">
<code class="descname">subtract_points</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em>, <em>xySecond=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.subtract_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract second set of points after interpolation on first set coordinates.
If xySecond is set to True data are interpolate on xy of p2 and then subtracted.</p>
</dd></dl>

<dl class="method">
<dt id="pySurf.PointCloud.Points.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.PointCloud.Points.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>returns translated coordinates of 2D point(s) x ([Npoints x 2]) by an offset.
It works also on 3-D points, in that case the z is returned unchanged.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="pySurf.PointCloud.method">
<code class="descclassname">pySurf.PointCloud.</code><code class="descname">method</code><em class="property"> = 'linear'</em><a class="headerlink" href="#pySurf.PointCloud.method" title="Permalink to this definition">¶</a></dt>
<dd><p>Finally a point class, inherited from numpy array.
Points are in format (Npoints,Ndim), where the last column is intended to be the data</p>
<blockquote>
<div>and the first N-1 are the points coordinate. This in the most general case, but routines
are written and tested on the 3d case. The final intent is make it valid for any ndim
for an array of 2d shape. Routines made for ndimensional case are marked with ND, routines
that need adjustment are marked as 3D.</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-pySurf.affine2D">
<span id="pysurf-affine2d-module"></span><h2>pySurf.affine2D module<a class="headerlink" href="#module-pySurf.affine2D" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.affine2D.apply2D">
<code class="descclassname">pySurf.affine2D.</code><code class="descname">apply2D</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.affine2D.apply2D" title="Permalink to this definition">¶</a></dt>
<dd><p>given a function acting on 2D points as array[N,2], returns a function
that do same action on first two coordinates of a 3D array, leaving the third unchanged.
e.g. rototrans_func=apply2D(translate_points(rotate_points()))</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.affine2D.find_affine">
<code class="descclassname">pySurf.affine2D.</code><code class="descname">find_affine</code><span class="sig-paren">(</span><em>markers1</em>, <em>markers2</em>, <em>pars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.affine2D.find_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function that can transform points from the first system to the second. Also return the matrix A of the transformation, that can be applied to a vector x with unpad(np.dot(pad(x), A)).
markers1 and markers2 are sets of points in format [Npoints, Ndim]. Transformation matrix A is [Ndim+1 x Ndim+1].
If list is passed in pars, transformation parameters mrot,b1,bartrans are appended.
<a class="reference external" href="http://stackoverflow.com/questions/20546182/how-to-perform-coordinates-affine-transformation-using-python-part-2">http://stackoverflow.com/questions/20546182/how-to-perform-coordinates-affine-transformation-using-python-part-2</a></p>
</dd></dl>

<dl class="function">
<dt id="pySurf.affine2D.find_rototrans">
<code class="descclassname">pySurf.affine2D.</code><code class="descname">find_rototrans</code><span class="sig-paren">(</span><em>markers1</em>, <em>markers2</em>, <em>pars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.affine2D.find_rototrans" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transformation that applied to markers1 gives markers2.
If list is passed in pars, transformation parameters mrot,b1,bartrans are appended.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.affine2D.plot_transform">
<code class="descclassname">pySurf.affine2D.</code><code class="descname">plot_transform</code><span class="sig-paren">(</span><em>points</em>, <em>plotLines=None</em>, <em>labels=None</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.affine2D.plot_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>plot a set of points or shapes and their transformed.
points is a list of sets of coordinates, one for each groups of points to be plotted with same style and transformation. Stile and transformation can be passed as single value or list.
plotlines is an array of flags to plot as lines(True) or points (False,default).
labels set of labels of same length
transform list (same len as points) of transformation functions or single function to be
applied respectively to each set of points passed.</p>
<p>#this plots some markers and a rectangle (see examples in module):
plt.figure() plot_transform([primary,secondary,rect1],[0,0,1],[&#8216;markers1&#8217;,&#8217;markers2&#8217;,&#8217;ROI&#8217;],[transform2,None,transform2])
plt.show()
display(plt.gcf())</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.affine2D.rot_center_func">
<code class="descclassname">pySurf.affine2D.</code><code class="descname">rot_center_func</code><span class="sig-paren">(</span><em>theta</em>, <em>center=(0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.affine2D.rot_center_func" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.affine2D.rototrans_func">
<code class="descclassname">pySurf.affine2D.</code><code class="descname">rototrans_func</code><span class="sig-paren">(</span><em>theta</em>, <em>center=(0</em>, <em>0)</em>, <em>offset=(0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.affine2D.rototrans_func" title="Permalink to this definition">¶</a></dt>
<dd><p>return a function that rotate by theta about center THEN translate by offset</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.affine2D.translate_func">
<code class="descclassname">pySurf.affine2D.</code><code class="descname">translate_func</code><span class="sig-paren">(</span><em>offset=(0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.affine2D.translate_func" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="pysurf-clip-module">
<h2>pySurf.clip module<a class="headerlink" href="#pysurf-clip-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pySurf.cmmconvert">
<span id="pysurf-cmmconvert-module"></span><h2>pySurf.cmmconvert module<a class="headerlink" href="#module-pySurf.cmmconvert" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.cmmconvert.cmmconvert">
<code class="descclassname">pySurf.cmmconvert.</code><code class="descname">cmmconvert</code><span class="sig-paren">(</span><em>filename</em>, <em>startline</em>, <em>step</em>, <em>outfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.cmmconvert.cmmconvert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pySurf.data2D">
<span id="pysurf-data2d-module"></span><h2>pySurf.data2D module<a class="headerlink" href="#module-pySurf.data2D" title="Permalink to this headline">¶</a></h2>
<p>Similar to points, but manage matrix data with x and y. All functions accept arguments in form data,x,y where x and y can be optional in some routines.</p>
<p># 2016/10/09 copied from PSDanalysis.py, quite rough, it contains also psd functions that should go in psd2d.</p>
<dl class="function">
<dt id="pySurf.data2D.calculate_slope_2D">
<code class="descclassname">pySurf.data2D.</code><code class="descname">calculate_slope_2D</code><span class="sig-paren">(</span><em>wdata</em>, <em>x</em>, <em>y</em>, <em>scale=(1.0</em>, <em>1.0</em>, <em>1.0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.calculate_slope_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate slope maps in x and y.
return slope in x and y respectively.
Set scale to (dx,dy,1000.) for z in micron, x,y in mm.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.compare_2images">
<code class="descclassname">pySurf.data2D.</code><code class="descname">compare_2images</code><span class="sig-paren">(</span><em>data</em>, <em>ldata</em>, <em>x=None</em>, <em>y=None</em>, <em>fignum=None</em>, <em>titles=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>commonscale=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.compare_2images" title="Permalink to this definition">¶</a></dt>
<dd><p>for backward compatibility, replaced by multiplot.compare_images. plot two images from data and ldata on a two panel figure with shared zoom.
x and y must be the same for the two data sets.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.crop_data">
<code class="descclassname">pySurf.data2D.</code><code class="descname">crop_data</code><span class="sig-paren">(</span><em>data</em>, <em>x</em>, <em>y</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>zrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.crop_data" title="Permalink to this definition">¶</a></dt>
<dd><p>return data,x,y</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.fitlegendre">
<code class="descclassname">pySurf.data2D.</code><code class="descname">fitlegendre</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>deg</em>, <em>nanstrict=False</em>, <em>fixnans=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.fitlegendre" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a legendre fit of degree deg. Work with 1 or 2D y (if 2D, each column is independently fit
and x is the coordinate of first axis.
if nanstrict is True, every column containing nan (or Inf) is considered invalid and a column of nan is returned, if False, nan are excluded and fit is calculated on valid points only (note that since columns
are slices along first index, the option has no effect on 1D data (nans are always returned as nans).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.get_data">
<code class="descclassname">pySurf.data2D.</code><code class="descname">get_data</code><span class="sig-paren">(</span><em>filename</em>, <em>x=None</em>, <em>y=None</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>matrix=False</em>, <em>addaxis=False</em>, <em>center=None</em>, <em>skip_header=None</em>, <em>delimiter=' '</em>, <em>autocrop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>read matrix from text file. Return data,x,y
center is the position of the center of the image in final coordinates (changed on 2016/08/10, it was &#8216;(before any scaling or rotation) in absolute coordinates.&#8217;) If None coordinates are left unchanged.</p>
<blockquote>
<div>Set to (0,0) to center the coordinate system to the data.</div></blockquote>
<dl class="docutils">
<dt>addaxis (if matrix is set) can be set to read values for axis in first row and column</dt>
<dd>(e.g. if points were saved with default addaxis=True in save_data.</dd>
<dt>autocrop remove frame of nans (external rows and columns made all of nans),</dt>
<dd>note it is done before centering. To include all data in centering, crop data
at a second time with remove_nan_frame</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.level_by_line">
<code class="descclassname">pySurf.data2D.</code><code class="descname">level_by_line</code><span class="sig-paren">(</span><em>data</em>, <em>function=None</em>, <em>axis=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.level_by_line" title="Permalink to this definition">¶</a></dt>
<dd><p>remove line through extremes line by line (along vertical lines).
The returned array has 0 at the ends, but not necessarily zero mean.
If fignum is set, plot comparison in corresponding figure.
Function is a function of profile vector y that returns a corrected profile.</p>
<p>Completely useless, can be replaced by np.apply_along_axis</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.leveldata">
<code class="descclassname">pySurf.data2D.</code><code class="descname">leveldata</code><span class="sig-paren">(</span><em>wdata</em>, <em>xwg</em>, <em>ywg</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.leveldata" title="Permalink to this definition">¶</a></dt>
<dd><p>plot and return matrices of wdata, lwdata, lwdata2
from data wdata. use polynomial fit, non legendre, each line is leveled on
extremes, not on zero piston/tilt</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.levellegendre">
<code class="descclassname">pySurf.data2D.</code><code class="descname">levellegendre</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>deg</em>, <em>nanstrict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.levellegendre" title="Permalink to this definition">¶</a></dt>
<dd><p>remove degree polyomial by line, evolution of leveldata using legendre functions
that work also 2D. nr. of terms fitted in legendre is deg+1 (piston-&gt;deg=0).
For 2D data, data are passed as second argument (y) and y coordinates passed as first (x) (legendre are leveled along columns)</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.levelpoints">
<code class="descclassname">pySurf.data2D.</code><code class="descname">levelpoints</code><span class="sig-paren">(</span><em>w0</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.levelpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>plot and return matrices of wdata, lwdata, lwdata2
from points w0</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.make_prof_legendre">
<code class="descclassname">pySurf.data2D.</code><code class="descname">make_prof_legendre</code><span class="sig-paren">(</span><em>x</em>, <em>coeff</em>, <em>inanp=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.make_prof_legendre" title="Permalink to this definition">¶</a></dt>
<dd><p>create a profile on x with legendre coefficients coeff.
Add nans on inanp indices.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.make_surf_legendre">
<code class="descclassname">pySurf.data2D.</code><code class="descname">make_surf_legendre</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>coeff</em>, <em>inanp=[]</em>, <em>inanl=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.make_surf_legendre" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.data2D.mark_data">
<code class="descclassname">pySurf.data2D.</code><code class="descname">mark_data</code><span class="sig-paren">(</span><em>datalist</em>, <em>outfile=None</em>, <em>deg=1</em>, <em>levelfunc=None</em>, <em>propertyname='markers'</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.mark_data" title="Permalink to this definition">¶</a></dt>
<dd><p>plot all data in a set of subplots. Allows to interactively put markers
on each of them. Return list of axis with attached property &#8216;markers&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.matrix_project">
<code class="descclassname">pySurf.data2D.</code><code class="descname">matrix_project</code><span class="sig-paren">(</span><em>data</em>, <em>axis=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.matrix_project" title="Permalink to this definition">¶</a></dt>
<dd><p>project a matrix along an axis and return, min, mean and max.
For backward compatibility, replaced by projection
(note different default axis).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.plot_data">
<code class="descclassname">pySurf.data2D.</code><code class="descname">plot_data</code><span class="sig-paren">(</span><em>data</em>, <em>x</em>, <em>y</em>, <em>title=None</em>, <em>outfile=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.plot_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.data2D.plot_slope_2D">
<code class="descclassname">pySurf.data2D.</code><code class="descname">plot_slope_2D</code><span class="sig-paren">(</span><em>wdata</em>, <em>x</em>, <em>y</em>, <em>scale=(1.0</em>, <em>1.0</em>, <em>1.0)</em>, <em>vrange=None</em>, <em>srange=None</em>, <em>filter=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.plot_slope_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>use calculate_slope_2D to calculate slope and
plot map and slice slope rms in x and y. Return the three axis.
Set scale to (1,1,1000.) for z in micron, x,y in mm.
If filter is set, data out of srange are removed and natural scale is</p>
<blockquote>
<div>used for plot. If not, srange is used for plot axis, but all data
are used in plots and rms calculation.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.plot_slope_slice">
<code class="descclassname">pySurf.data2D.</code><code class="descname">plot_slope_slice</code><span class="sig-paren">(</span><em>wdata</em>, <em>x</em>, <em>y</em>, <em>scale=(1.0</em>, <em>1.0</em>, <em>1.0)</em>, <em>vrange=None</em>, <em>srange=None</em>, <em>filter=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.plot_slope_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>use calculate_slope_2D to calculate slope and
plot map and respective slope maps in x and y. Return the three axis.
Set scale to (1,1,1000.) for z in micron, x,y in mm.
If filter is set, data out of srange are removed and natural scale is</p>
<blockquote>
<div>used for plot. If not, srange is used for plot axis, but all data
are used in plots and rms calculation.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.projection">
<code class="descclassname">pySurf.data2D.</code><code class="descname">projection</code><span class="sig-paren">(</span><em>data</em>, <em>axis=0</em>, <em>span=False</em>, <em>expand=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>return average along axis. default axis is 0, profile along x.
keywords give extended results:
span: if set, return  3 vectors [avg, min, max] with min and max calculated pointwise along same direction.
expand: instead of a single vector with point-wise minima, returns lists of all vectors having at least one point</p>
<blockquote>
<div>that is minimum (maximum) between all vectors parallel to axis. Overrides span.</div></blockquote>
<p>ex:
a=array([[21, 16,  3, 14],</p>
<blockquote>
<div>[22, 17,  6, 15],
[ 0,  3, 21, 16]])</div></blockquote>
<p>In [62]: projection(a)
Out[62]: array([ 14.33333333,12.,10.,15.])</p>
<p>In [73]: projection(a,span=True)
Out[73]:
[array([ 14.33333333,12.,10.,15.]),</p>
<blockquote>
<div>array([ 0,  3,  3, 14]),
array([22, 17, 21, 16])]</div></blockquote>
<p>In [71]: projection(a,expand=True)
Out[71]:
[array([ 14.33333333,12.,10.,15.]),</p>
<blockquote>
<div>array([[21, 16,  3, 14],[ 0,  3, 21, 16]]),
array([[22, 17,  6, 15],[ 0,  3, 21, 16]])]</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.remove_nan_frame">
<code class="descclassname">pySurf.data2D.</code><code class="descname">remove_nan_frame</code><span class="sig-paren">(</span><em>data</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.remove_nan_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all external rows and columns that contains only nans</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.removelegendre">
<code class="descclassname">pySurf.data2D.</code><code class="descname">removelegendre</code><span class="sig-paren">(</span><em>x</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.removelegendre" title="Permalink to this definition">¶</a></dt>
<dd><p>remove degree polyomial, a possible leveling function for leveldata.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.removept">
<code class="descclassname">pySurf.data2D.</code><code class="descname">removept</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.removept" title="Permalink to this definition">¶</a></dt>
<dd><p>remove piston and tilt, a possible leveling functiondata for leveldata.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.removesag">
<code class="descclassname">pySurf.data2D.</code><code class="descname">removesag</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.removesag" title="Permalink to this definition">¶</a></dt>
<dd><p>remove second degree polyomial, a possible leveling functiondata for leveldata.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.save_data">
<code class="descclassname">pySurf.data2D.</code><code class="descname">save_data</code><span class="sig-paren">(</span><em>filename</em>, <em>data</em>, <em>x=None</em>, <em>y=None</em>, <em>fill_value=nan</em>, <em>addaxis=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.save_data" title="Permalink to this definition">¶</a></dt>
<dd><p>save points on a file. If matrix is true write in matrix form (in this case you have to
provide the values for axis). Otherwise write as points in columns.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.test_profile_legendre">
<code class="descclassname">pySurf.data2D.</code><code class="descname">test_profile_legendre</code><span class="sig-paren">(</span><em>nans=True</em>, <em>fixnans=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.test_profile_legendre" title="Permalink to this definition">¶</a></dt>
<dd><p>test on a list of 2D coefficients creating profile then fitting with
numpy routines and with data2D routine fitlegendre
(wrapper around numpy to handle nans).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.data2D.test_surf_legendre">
<code class="descclassname">pySurf.data2D.</code><code class="descname">test_surf_legendre</code><span class="sig-paren">(</span><em>nans=True</em>, <em>fixnans=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.data2D.test_surf_legendre" title="Permalink to this definition">¶</a></dt>
<dd><p>test how 1D (line) routines in polynomial.legendre work on 1D and 2D data.
If nanpoints=0 nan are not put in data. If nanpoints=1 or 2 nans are added on some points and
some lines, with value value of nanpoints determineing the option nanstrict of levellegendre
(1=false, 2=true).</p>
</dd></dl>

</div>
<div class="section" id="pysurf-data2dclass-module">
<h2>pySurf.data2Dclass module<a class="headerlink" href="#pysurf-data2dclass-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pySurf.distanceTable">
<span id="pysurf-distancetable-module"></span><h2>pySurf.distanceTable module<a class="headerlink" href="#module-pySurf.distanceTable" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.distanceTable.defaultDist">
<code class="descclassname">pySurf.distanceTable.</code><code class="descname">defaultDist</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.distanceTable.defaultDist" title="Permalink to this definition">¶</a></dt>
<dd><p>demenziale distanza euclidea</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.distanceTable.distanceTable">
<code class="descclassname">pySurf.distanceTable.</code><code class="descname">distanceTable</code><span class="sig-paren">(</span><em>pList</em>, <em>dist=&lt;function eucDist at 0x000000000B337828&gt;</em>, <em>format=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.distanceTable.distanceTable" title="Permalink to this definition">¶</a></dt>
<dd><p>from list of points pList, create table of distances.
dist is a function setting a metric, if format is format string, if provided result is converted to string using the format</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.distanceTable.eucDist">
<code class="descclassname">pySurf.distanceTable.</code><code class="descname">eucDist</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.distanceTable.eucDist" title="Permalink to this definition">¶</a></dt>
<dd><p>demenziale distanza euclidea</p>
</dd></dl>

</div>
<div class="section" id="pysurf-fit-cylinder-module">
<h2>pySurf.fit_cylinder module<a class="headerlink" href="#pysurf-fit-cylinder-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pySurf.fit_cylinder_edit">
<span id="pysurf-fit-cylinder-edit-module"></span><h2>pySurf.fit_cylinder_edit module<a class="headerlink" href="#module-pySurf.fit_cylinder_edit" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.fit_cylinder_edit.closest_point_on_line">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">closest_point_on_line</code><span class="sig-paren">(</span><em>points</em>, <em>lVersor</em>, <em>lPoint</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.closest_point_on_line" title="Permalink to this definition">¶</a></dt>
<dd><p>From a list of points in 3D space as Nx3 array, returns a Nx3 array with the corresponding closest points on the line.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.cone_error">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">cone_error</code><span class="sig-paren">(</span><em>odr=(0</em>, <em>0</em>, <em>0</em>, <em>0</em>, <em>0</em>, <em>0)</em>, <em>points=None</em>, <em>extra=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.cone_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of N points in format Nx3, returns the rms surface error on the cone defined by origin (intercept of the axis with x=0) and direction,
passed as 4-vector odr(origin_y,origin_z,direction_x,direction_z).
Best fit cone for odr is calculated from linear fit of data.
If extra is set, additional values are returned :
coeff: best fit radius for the cone as [m,q] for x&#8217; distance from x=0 plan on cone axis R(x&#8217;)=m x&#8217; + q. Half cone angle is atan(m).
deltaR[N,3]: deviation from radius for each point.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.cone_error3">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">cone_error3</code><span class="sig-paren">(</span><em>odr=(0</em>, <em>220.0</em>, <em>0</em>, <em>0)</em>, <em>points=None</em>, <em>coeff=None</em>, <em>extra=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.cone_error3" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of N points in format Nx3, returns the rms surface error on the cone defined by
its axis (radius and apex are determined by best fit).
Axis is defined as a 4 elements vector odr=(x,z,cx,cz), not in xz plane.
origin (intercept of the axis with y=0) and director cosines.
If coeff is passed as input, the fit for cone surface is not performed and the coeff values are used.
If extra is set, additional values are returned :
coeff: best fit radius for the cone as [m,q] for x&#8217; distance from x=0 plan on cone axis R(x&#8217;)=m x&#8217; + q. Half cone angle is atan(m).
deltaR[N,3]: deviation from radius for each point. Bump positive convention (smaller radius is positive).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.cylinder_error">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">cylinder_error</code><span class="sig-paren">(</span><em>odr=(0</em>, <em>0</em>, <em>0</em>, <em>0</em>, <em>0</em>, <em>0)</em>, <em>points=None</em>, <em>extra=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.cylinder_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of N points in format Nx3, returns the   error on the cylinder defined by origin and direction as a 6(3+3) dim vector.
If extra is set, additional values are returned :</p>
<blockquote>
<div>radius: best fit radius for the cylinder.
deltaR[N,3]: deviation from radius for each point.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.cylinder_error3">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">cylinder_error3</code><span class="sig-paren">(</span><em>odr=(0</em>, <em>0</em>, <em>0</em>, <em>0)</em>, <em>points=None</em>, <em>radius=None</em>, <em>extra=False</em>, <em>xy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.cylinder_error3" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of N points in format Nx3, returns the rms surface error on the cylinder defined by origin (intercept of the axis with x=0) and direction,
passed as 4-vector odr (origin_y,origin_z,direction_x,direction_z).</p>
<blockquote>
<div>with directions components of axis versor along the respective coordinate.</div></blockquote>
<dl class="docutils">
<dt>Best fit radius for odr is calculated as average if not provided. If provided as input it is</dt>
<dd>not optimized.</dd>
<dt>If extra is set, additional values are returned :</dt>
<dd>radius: best fit radius for the cylinder.
deltaR[N,3]: deviation from radius for each point.</dd>
<dt>nan must be filtered before calling the function, useful if the functino is called many time</dt>
<dd>e.g. in optimization.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.fit_cone">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">fit_cone</code><span class="sig-paren">(</span><em>pts</em>, <em>odr2</em>, <em>zscale=1.0</em>, <em>keepnan=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.fit_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>fit pts and return residuals. Info are printed. odr2 is starting guess.
typically:
odr2=(span(xg).sum()/2.,220.,0,0.) #use nominal value for guess direction
fom,deltaR,pars=fit_cone(pts,odr2,fit_func)
zscale is the factor to multiply data to obtain same units as x and y,
e.g. 1000. for x and y in mm and z in um. Output is in same unit as input.
pts and deltaR enter and exit with z in microns
parameters for optimization can be passed as keyword arguments, e.g.:
fom,deltaR,pars=fit_cone(pts,odr2,fit_func,options={&#8216;maxiter&#8217;:500},method=&#8217;Nelder-Mead&#8217;)</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.fit_cylinder">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">fit_cylinder</code><span class="sig-paren">(</span><em>pts</em>, <em>odr2</em>, <em>zscale=1.0</em>, <em>keepnan=False</em>, <em>align=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.fit_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>fit pts and return residuals. Info are printed.
odr2: starting guess. typically: odr2=(span(xg).sum()/2.,220.,0,0.)</p>
<blockquote>
<div>fom,deltaR,pars=fit_cylinder(pts,odr2,fit_func)</div></blockquote>
<dl class="docutils">
<dt>zscale: factor to divide data to obtain same units as x and y,</dt>
<dd>e.g. 1000. for x and y in mm and z in um. Output is in same unit as input.</dd>
<dt>parameters for optimization with scipy.optimize.minimize can be passed as keyword arguments,</dt>
<dd>e.g.: deltaR,odr=fit_cylinder(c,odr2,options={&#8216;maxiter&#8217;:500},method=&#8217;Nelder-Mead&#8217;)</dd>
<dt>if keepnan is set True nans are reinserted after the fit keeping same size for array,</dt>
<dd>otherwise nans are removed.</dd>
</dl>
<p>if align is set True, rotate data to align axis and return residuals on rotated grid (can be resampled on data or viceversa
with resample_points)</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.subtract_cone">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">subtract_cone</code><span class="sig-paren">(</span><em>pp</em>, <em>odr</em>, <em>sampleName=''</em>, <em>outfile=None</em>, <em>vmin=None</em>, <em>vmax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.subtract_cone" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>odr: 6-vector (origin_y,origin_y,origin_z,direction_x,direction_y,direction_z),</dt>
<dd>note that  this is redundant, since only two components are enough for direction
(magnitude is irrelevant).</dd>
</dl>
<p>pp: complete set of points Npx3</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.fit_cylinder_edit.subtract_cylinder">
<code class="descclassname">pySurf.fit_cylinder_edit.</code><code class="descname">subtract_cylinder</code><span class="sig-paren">(</span><em>pp</em>, <em>odr</em>, <em>sampleName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.fit_cylinder_edit.subtract_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>odr: 6-vector (origin_y,origin_y,origin_z,direction_x,direction_y,direction_z),</dt>
<dd>note that  this is redundant, since only two components are enough for direction
(magnitude is irrelevant).</dd>
</dl>
<p>pp: complete set of points Npx3</p>
</dd></dl>

</div>
<div class="section" id="module-pySurf.instrumentReader">
<span id="pysurf-instrumentreader-module"></span><h2>pySurf.instrumentReader module<a class="headerlink" href="#module-pySurf.instrumentReader" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.instrumentReader.FEAreader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">FEAreader</code><span class="sig-paren">(</span><em>FEAfile</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.FEAreader" title="Permalink to this definition">¶</a></dt>
<dd><p>read V. Marquez files, keeping original orientation and variables.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.bin_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">bin_reader</code><span class="sig-paren">(</span><em>wfile, index=0, ytox=1.0, zscale=1.0, crop=[None, None, None], center=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.bin_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a binary .npy file containing a list of lists in form (imdata, dx).
Can crop data and translate on three coordinates. crop is calculated on raw data,
center is the position of the central point after crop and scaling.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.fitsAFM_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">fitsAFM_reader</code><span class="sig-paren">(</span><em>fitsfile</em>, <em>sizeum=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.fitsAFM_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>return x,y (vectors) and data (matrix) from fits file. AFM file</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.fitsCCI_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">fitsCCI_reader</code><span class="sig-paren">(</span><em>fitsfile</em>, <em>center=None</em>, <em>head=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.fitsCCI_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>return x,y (vectors) and data (matrix) from fits CCI file.
center can be none, in which case data are not centered.
To extract center position from header, use center=(None,None).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.fitsWFS_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">fitsWFS_reader</code><span class="sig-paren">(</span><em>wfile, ypix=1.0, ytox=1.0, zscale=1.0, crop=[None, None, None], center=None, strip=False, scale=(1, 1, 1.0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.fitsWFS_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>return data (matrix) and x,y (vectors) from fits WFS file.
I don&#8217;t  understand very well order of data, inverting data
works for S22 for bump positive, but sample seems rotated and
horizontally flipped.
If strip is set, nan are removed, it doesn&#8217;t really work with ranges.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.fitsWFS_reader2">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">fitsWFS_reader2</code><span class="sig-paren">(</span><em>fitsfile</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>zrange=None</em>, <em>strip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.fitsWFS_reader2" title="Permalink to this definition">¶</a></dt>
<dd><p>return data (matrix) and x,y (vectors) from fits WFS file.
I don&#8217;t  understand very well order of data, inverting data
works for S22 for bump positive, but sample seems rotated and
horizontally flipped.
If strip is set, nan are removed, it doesn&#8217;t really work with ranges.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.fits_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">fits_reader</code><span class="sig-paren">(</span><em>fitsfile</em>, <em>scale=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.fits_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic fits file reader. Return x,y (vectors) and data (matrix).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.getdata">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">getdata</code><span class="sig-paren">(</span><em>fitsfile</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.getdata" title="Permalink to this definition">¶</a></dt>
<dd><p>return x,y (vectors) and data (matrix) from fits file.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.matrix4D_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">matrix4D_reader</code><span class="sig-paren">(</span><em>wfile</em>, <em>ypix=1.0</em>, <em>ytox=1.0</em>, <em>zscale=1.0</em>, <em>crop=None</em>, <em>center=None</em>, <em>strip=False</em>, <em>scale=(1</em>, <em>1</em>, <em>1.0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.matrix4D_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a data matrix from csv as saved by 4D.
ypix is the size of pixel in vertical direction.
ytox the conversion factor (typically given by radius of test optics/radius of CGH).
Can crop data and translate on three coordinates. crop is calculated on raw data,
center is the position of the central point after crop and scaling.
If strip is set, nan are stripped and center is calculated on valid data only.
Scale applies to data after applying ypix and ytox, but before centering.</p>
<blockquote>
<div>It can be used e.g. to invert x axis as in measuring 220 mm mandrel with 1 m CGH (scale=(-1,1,1)).</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.matrixZygo_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">matrixZygo_reader</code><span class="sig-paren">(</span><em>wfile</em>, <em>ypix=1.0</em>, <em>ytox=1.0</em>, <em>zscale=1.0</em>, <em>crop=None</em>, <em>center=None</em>, <em>strip=False</em>, <em>scale=(1</em>, <em>-1</em>, <em>1.0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.matrixZygo_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a data matrix from csv as saved by Zygo.
ypix is the size of pixel in vertical direction.
ytox the conversion factor (typically given by radius of test optics/radius of CGH).
Can crop data and translate on three coordinates. crop is calculated on raw data,
center is the position of the central point after crop and scaling.
If strip is set, nan are stripped and center is calculated on valid data only.
Scale applies to data after applying ypix and ytox, but before centering.</p>
<blockquote>
<div>It can be used e.g. to invert x axis as in measuring 220 mm mandrel with 1 m CGH (scale=(-1,1,1)).</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.points_reader">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">points_reader</code><span class="sig-paren">(</span><em>wfile</em>, <em>crop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.points_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a processed points file as csv output of analysis routines.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.instrumentReader.test_zygo">
<code class="descclassname">pySurf.instrumentReader.</code><code class="descname">test_zygo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.instrumentReader.test_zygo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pySurf.outliers2d">
<span id="pysurf-outliers2d-module"></span><h2>pySurf.outliers2d module<a class="headerlink" href="#module-pySurf.outliers2d" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.outliers2d.remove_outliers2d">
<code class="descclassname">pySurf.outliers2d.</code><code class="descname">remove_outliers2d</code><span class="sig-paren">(</span><em>data</em>, <em>x=None</em>, <em>y=None</em>, <em>nsigma=3</em>, <em>fignum=None</em>, <em>name=''</em>, <em>includenan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.outliers2d.remove_outliers2d" title="Permalink to this definition">¶</a></dt>
<dd><p>remove outliers line by line by interpolation (along vertical lines).
If fignum is set, plot comparison in corresponding figure.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.outliers2d.remove_outliers2d2">
<code class="descclassname">pySurf.outliers2d.</code><code class="descname">remove_outliers2d2</code><span class="sig-paren">(</span><em>data</em>, <em>x=None</em>, <em>y=None</em>, <em>nsigma=3</em>, <em>degree=1</em>, <em>fignum=None</em>, <em>name=''</em>, <em>includenan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.outliers2d.remove_outliers2d2" title="Permalink to this definition">¶</a></dt>
<dd><p>remove outliers by comparing with average line profile.</p>
</dd></dl>

</div>
<div class="section" id="module-pySurf.plane_fit">
<span id="pysurf-plane-fit-module"></span><h2>pySurf.plane_fit module<a class="headerlink" href="#module-pySurf.plane_fit" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.plane_fit.plane_fit">
<code class="descclassname">pySurf.plane_fit.</code><code class="descname">plane_fit</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.plane_fit.plane_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>#modified by kov
#x,y,z 3 vectors with coordinates of points (same number of elements).
#return value [A,B,C] of plane Ax + By + C = z
#planesurf is a vector with z of plane points</p>
<p>#compute the average surface, calculate statistical indicator
# z can be nan, if there are nan in x and y it is likely not to woork.</p>
<blockquote>
<div># M. Katz 1/26/04</div></blockquote>
<p># IDL function to perform a least-squares fit a plane, based on
# Ax + By + C = z
#
# ABC = plane_fit(x, y, z, error=error)</p>
</dd></dl>

</div>
<div class="section" id="module-pySurf.points">
<span id="pysurf-points-module"></span><h2>pySurf.points module<a class="headerlink" href="#module-pySurf.points" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.points.clipStats">
<code class="descclassname">pySurf.points.</code><code class="descname">clipStats</code><span class="sig-paren">(</span><em>p</em>, <em>clip</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.clipStats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.points.crop_points">
<code class="descclassname">pySurf.points.</code><code class="descname">crop_points</code><span class="sig-paren">(</span><em>points</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>zrange=None</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.crop_points" title="Permalink to this definition">¶</a></dt>
<dd><p>crop a xyz points [Nx3], keeping only points inside xrange and yrange defined as (min,max).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.crop_points2">
<code class="descclassname">pySurf.points.</code><code class="descname">crop_points2</code><span class="sig-paren">(</span><em>points</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>zrange=None</em>, <em>mask=None</em>, <em>boolean=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.crop_points2" title="Permalink to this definition">¶</a></dt>
<dd><p>experimental version, adds option booleam to return mask. useful e.g. to clean data based on crop on deltaR</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.extract_profile">
<code class="descclassname">pySurf.points.</code><code class="descname">extract_profile</code><span class="sig-paren">(</span><em>points</em>, <em>xy0</em>, <em>xy1=None</em>, <em>npoints=100</em>, <em>along=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.extract_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>extract a profile from xy0=(x0, y0) to xy1=(x1,y1).
Return a couple of vectors x, y, z. The number of points can be set, otherwise is set
accordingly to the longest profile dimension.
If along is set (default), a two-dim x-z profile is returned with x distancce
along the profile from xy0.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.get_points">
<code class="descclassname">pySurf.points.</code><code class="descname">get_points</code><span class="sig-paren">(</span><em>filename</em>, <em>x=None</em>, <em>y=None</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>matrix=False</em>, <em>addaxis=False</em>, <em>scale=None</em>, <em>center=None</em>, <em>skip_header=None</em>, <em>delimiter='</em>, <em>'</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>return a set of xyz points (N,3) from nanovea saved txt (matrix=False)
or gwyddion saved matrix (matrix=True, xrange, yrange must be defined).
scale is used to scale the
center is the position of the center of the image in final coordinates (changed on 2016/08/10, it was &#8216;(before any scaling or rotation) in absolute coordinates.&#8217;) If None coordinates are left unchanged.</p>
<blockquote>
<div>Set to (0,0) to center the coordinate system to the data.</div></blockquote>
<dl class="docutils">
<dt>addaxis (if matrix is set) can be set to read values for axis in first row and column</dt>
<dd>(e.g. if points were saved with default addaxis=True in save_points.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.histostats">
<code class="descclassname">pySurf.points.</code><code class="descname">histostats</code><span class="sig-paren">(</span><em>points</em>, <em>bins=100</em>, <em>log=True</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.histostats" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot histogram of z. Accept arguments for plt.hist.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.level_points">
<code class="descclassname">pySurf.points.</code><code class="descname">level_points</code><span class="sig-paren">(</span><em>points</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>zrange=None</em>, <em>mask=None</em>, <em>pars=None</em>, <em>retall=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.level_points" title="Permalink to this definition">¶</a></dt>
<dd><p>return the leveled points (after subtraction of best fit plane on selected points).
If pars is provided as 3 elements vector is intended as plane coefficients and fit is not performed.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.matrix_to_points">
<code class="descclassname">pySurf.points.</code><code class="descname">matrix_to_points</code><span class="sig-paren">(</span><em>data</em>, <em>xgrid</em>, <em>ygrid</em>, <em>transpose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.matrix_to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>this assumes that the order in data (after flattening) follows the order of
x and y in meshgrid. If not (vertical direction first), set flag transpose.
Not tested on arrays with different x and y, potentially a mess.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.matrix_to_points2">
<code class="descclassname">pySurf.points.</code><code class="descname">matrix_to_points2</code><span class="sig-paren">(</span><em>mdata</em>, <em>x=None</em>, <em>y=None</em>, <em>xrange=None</em>, <em>yrange=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.matrix_to_points2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="pySurf.points.method">
<code class="descclassname">pySurf.points.</code><code class="descname">method</code><em class="property"> = 'linear'</em><a class="headerlink" href="#pySurf.points.method" title="Permalink to this definition">¶</a></dt>
<dd><p>2014/03/17 moved here all routines from EA2019_align and from OP1S07_align.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.plot_points">
<code class="descclassname">pySurf.points.</code><code class="descname">plot_points</code><span class="sig-paren">(</span><em>points</em>, <em>xgrid=None</em>, <em>ygrid=None</em>, <em>shape=None</em>, <em>resample=True</em>, <em>scatter=False</em>, <em>contours=0</em>, <em>bar=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.plot_points" title="Permalink to this definition">¶</a></dt>
<dd><p>resample xyz points [Nx3] to a grid whose axis xgrid and ygrid are given
and plot it. If resample is set to False x and y positions are considered only for range,
but they are not used to position the z values (it works if x and y are on an exact unrotated grid,
resampling is slower, but exact).
shape is in format (nx,ny) that is opposite to python convention.
contours is contour spacing.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.points_autoresample">
<code class="descclassname">pySurf.points.</code><code class="descname">points_autoresample</code><span class="sig-paren">(</span><em>points</em>, <em>cut=0</em>, <em>resample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_autoresample" title="Permalink to this definition">¶</a></dt>
<dd><p>Use points_find_grid to determine the grid for points and resample.
It should give minimal alteration of points when close to grid.
This routine returns data,x,y
Same result can be obtained by calling
resample_grid (without providing x and y)
AND points_find_grid to determine x and y.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.points_find_grid">
<code class="descclassname">pySurf.points.</code><code class="descname">points_find_grid</code><span class="sig-paren">(</span><em>points</em>, <em>result='shape'</em>, <em>sort=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_find_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Given points as pointcloud, do some basic guess on shape and axis orientation
of the grid. Not many checks in this first version, you need to verify results.
Works for raster points, even irregular and non rectangular, but not for scatter (step is estimated from the first two
elements, it fails if elements are not sorted, points can be
sorted xy or yx to avoid failure, like (xysort):</p>
<blockquote>
<div>a = a[a[:,1].argsort()]
a = a[a[:,0].argsort(kind=&#8217;mergesort&#8217;)] #stable sort.</div></blockquote>
<p>Return a tuple (fastind,result), fastind is 1 for y and 0 for x,
result can be &#8216;shape&#8217;, &#8216;step&#8217;  or &#8216;grid&#8217;.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.points_find_hull">
<code class="descclassname">pySurf.points.</code><code class="descname">points_find_hull</code><span class="sig-paren">(</span><em>pts</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_find_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>return the convex hull non containing invalid (nan) points as a (np,2) array.
hull=points_find_hull(pts)
plt.plot(hull[:,0], hull[:,1], &#8216;r&#8211;&#8217;, lw=2).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.points_rms">
<code class="descclassname">pySurf.points.</code><code class="descname">points_rms</code><span class="sig-paren">(</span><em>points</em>, <em>xrange=None</em>, <em>yrange=None</em>, <em>zrange=None</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_rms" title="Permalink to this definition">¶</a></dt>
<dd><p>return the rms of the selected points.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.rebin_points">
<code class="descclassname">pySurf.points.</code><code class="descname">rebin_points</code><span class="sig-paren">(</span><em>tpoints</em>, <em>matrix=False</em>, <em>steps=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.rebin_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.points.resample_grid">
<code class="descclassname">pySurf.points.</code><code class="descname">resample_grid</code><span class="sig-paren">(</span><em>tpoints</em>, <em>xgrid=None</em>, <em>ygrid=None</em>, <em>matrix=False</em>, <em>resample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.resample_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>resample tpoints [Npoints x 3] on the grid defined by two vectors xgrid [Nx] and ygrid [Ny].
Return a [Nx * Ny , 3] vector of points, sorted in standard python order
(x changes faster) or a matrix if matrix=True. if resample is set to False
only shape is changed and values are not touched (must maintain number of points).
matrix=True&#8211;&gt;points to matrix
matrix=False,resample=False-&gt; Convert from matrix to points without resampling if matrix input, useless if input is points (do two opposite operations that should cancel each other).
p=resample_grid(p) #straighten the grid of p changing data as little as possible</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.resample_points">
<code class="descclassname">pySurf.points.</code><code class="descname">resample_points</code><span class="sig-paren">(</span><em>tpoints</em>, <em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.resample_points" title="Permalink to this definition">¶</a></dt>
<dd><p>resample tpoints [Npoints x 3] on the points defined in positions [Mpoints x 2], or [Mpoints x 3]
(in this case 3rd column is ignored).
Return a [Nx x Ny , 3] vector of points. To get a (plottable) matrix of data use:
plt.imshow(rpoints[:,2].reshape(xgrid.size,ygrid.size)).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.roicircle_points">
<code class="descclassname">pySurf.points.</code><code class="descname">roicircle_points</code><span class="sig-paren">(</span><em>points</em>, <em>radius</em>, <em>missing=None</em>, <em>invert=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.roicircle_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Select points inside a circle of given radius. Points outside the circle are removed
or replaced by a missing value.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.rotate_points">
<code class="descclassname">pySurf.points.</code><code class="descname">rotate_points</code><span class="sig-paren">(</span><em>points</em>, <em>theta</em>, <em>center=(0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.rotate_points" title="Permalink to this definition">¶</a></dt>
<dd><p>returns rotated coordinates of 2D point(s) x ([Npoints x 2]) about a center with anticlockwise angle theta in rad. If 3D points are passed, z coordinate is maintained.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.save_points">
<code class="descclassname">pySurf.points.</code><code class="descname">save_points</code><span class="sig-paren">(</span><em>filename</em>, <em>points</em>, <em>xgrid=None</em>, <em>ygrid=None</em>, <em>shape=None</em>, <em>matrix=False</em>, <em>fill_value=nan</em>, <em>addaxis=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.save_points" title="Permalink to this definition">¶</a></dt>
<dd><p>save points on a file. If matrix is true write in matrix form (in this case you have to
provide the values for axis). Otherwise write as points in columns.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.smooth_points">
<code class="descclassname">pySurf.points.</code><code class="descname">smooth_points</code><span class="sig-paren">(</span><em>points</em>, <em>xywidth</em>, <em>xgrid=None</em>, <em>ygrid=None</em>, <em>shape=None</em>, <em>matrix=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.smooth_points" title="Permalink to this definition">¶</a></dt>
<dd><p>resample points on a grid and perform moving average smoothin in x and y according to xywidth,
if one component is None smoothing in that direction is not performed.
Return points in usual coordinates, unless matrix flag is set.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.smooth_points2">
<code class="descclassname">pySurf.points.</code><code class="descname">smooth_points2</code><span class="sig-paren">(</span><em>points</em>, <em>xywidth</em>, <em>xgrid=None</em>, <em>ygrid=None</em>, <em>shape=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.smooth_points2" title="Permalink to this definition">¶</a></dt>
<dd><p>NOT WORKING shape in format (nx,ny) as convention in points, opposite of python.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.subtract_points">
<code class="descclassname">pySurf.points.</code><code class="descname">subtract_points</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em>, <em>xySecond=False</em>, <em>resample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.subtract_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract second set of points after interpolation on first set coordinates.
If xySecond is set to True data are interpolate on xy of p2 and then subtracted.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.subtract_points2">
<code class="descclassname">pySurf.points.</code><code class="descname">subtract_points2</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em>, <em>xySecond=False</em>, <em>resample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.subtract_points2" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to make subtract_points faster by transposing and acting on faster slice</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.subtract_points_old">
<code class="descclassname">pySurf.points.</code><code class="descname">subtract_points_old</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em>, <em>xySecond=False</em>, <em>resample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.subtract_points_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract second set of points after interpolation on first set coordinates.
If xySecond is set to True data are interpolate on xy of p2 and then subtracted.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.points.translate_points">
<code class="descclassname">pySurf.points.</code><code class="descname">translate_points</code><span class="sig-paren">(</span><em>points</em>, <em>offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.translate_points" title="Permalink to this definition">¶</a></dt>
<dd><p>returns translated coordinates. Useless routine, can be done with
a simple sum points+offset</p>
</dd></dl>

</div>
<div class="section" id="module-pySurf.psd2d">
<span id="pysurf-psd2d-module"></span><h2>pySurf.psd2d module<a class="headerlink" href="#module-pySurf.psd2d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pySurf.psd2d.PSDplot">
<em class="property">class </em><code class="descclassname">pySurf.psd2d.</code><code class="descname">PSDplot</code><a class="headerlink" href="#pySurf.psd2d.PSDplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Contains a number of psds in form (f,psd).</p>
<dl class="method">
<dt id="pySurf.psd2d.PSDplot.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>psd</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.PSDplot.append" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pySurf.psd2d.PSDplot.append_from_file">
<code class="descname">append_from_file</code><span class="sig-paren">(</span><em>file</em>, <em>cols</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.PSDplot.append_from_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pySurf.psd2d.PSDplot.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.PSDplot.plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.addPSDs">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">addPSDs</code><span class="sig-paren">(</span><em>psdfile</em>, <em>cols</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.addPSDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Add to current plot a list of PSDs from a standard (12-col,1 line header) PSD file.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.avgpsd">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">avgpsd</code><span class="sig-paren">(</span><em>fitsfile</em>, <em>correct=False</em>, <em>reader=None</em>, <em>level=None</em>, <em>nsigma=3</em>, <em>rotate=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.avgpsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper on avgpsd2d. Extract average psd from a fits image,
includes reading and outliers removal.
Reader is a function of fitsfile that returns x,y,data.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.avgpsd2d">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">avgpsd2d</code><span class="sig-paren">(</span><em>psddata</em>, <em>axis=1</em>, <em>span=False</em>, <em>expand=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.avgpsd2d" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for backward compatibilty and tutorial,
use directly pySurf.data2D.projection() with axis=1 to get same effect.
return psd average along axis from 2d psd computed with same
orientation. default axis is 1, because axial profiles
are along axis 0, sum on axis 1.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.calculatePSD">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">calculatePSD</code><span class="sig-paren">(</span><em>wdata</em>, <em>xg</em>, <em>yg</em>, <em>outname=''</em>, <em>wfun=None</em>, <em>vrange=None</em>, <em>rmsrange=None</em>, <em>prange=None</em>, <em>fignum=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.calculatePSD" title="Permalink to this definition">¶</a></dt>
<dd><p>given points w, calculate and plot surface maps with different leveling (piston, tilt, sag, 10 legendre)
use psd2d to calculate and save x and y 2d PSDs, plots only y.
fignum window where to plot, if fignnum is 0 current figure is cleared, if None new figure is created. Default to figure 1 .</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.calculatePSD2">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">calculatePSD2</code><span class="sig-paren">(</span><em>wdata, xg, yg, outname='', wfun=None, vrange=[None, None], rmsrange=None, prange=None, fignum=1, misal_deg=(1, 1), leg_deg=(10, 10)</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.calculatePSD2" title="Permalink to this definition">¶</a></dt>
<dd><p>Updated version with subtracted 4 terms legendre.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.compare_2dpsd">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">compare_2dpsd</code><span class="sig-paren">(</span><em>data</em>, <em>ldata</em>, <em>x=None</em>, <em>y=None</em>, <em>fignum=None</em>, <em>titles=None</em>, <em>vmin=None</em>, <em>vmax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.compare_2dpsd" title="Permalink to this definition">¶</a></dt>
<dd><p>plot a four panel data and psd for the two figures from data and ldata.
x and y must be the same for the two data sets.
Calculate PSD. Return freqs, psd and lpsd.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.multipsd">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">multipsd</code><span class="sig-paren">(</span><em>datalist</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.multipsd" title="Permalink to this definition">¶</a></dt>
<dd><p>return a tuple of two couples ((yfreq.,ypsd),(xfreq.,xpsd))
for each of the data passed, respectively for y and x.
data must be passed as list of tuples (wdata,xwg,ywg)</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.multipsd2">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">multipsd2</code><span class="sig-paren">(</span><em>datalist</em>, <em>wfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.multipsd2" title="Permalink to this definition">¶</a></dt>
<dd><p>return two lists of vectors respectively freq and avg psd2
each list has vectors respectively for y and x for data must be passed as list of tuples, each one in form (wdata,xwg,ywg)</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.multipsd3">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">multipsd3</code><span class="sig-paren">(</span><em>wdata</em>, <em>xwg</em>, <em>ywg</em>, <em>wfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.multipsd3" title="Permalink to this definition">¶</a></dt>
<dd><p>return two lists respectively freq and psd2d
each list has vectors respectively for y and x for each data set passed.
data must be passed as list of tuples, each one in form (wdata,xwg,ywg)</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.mwc">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">mwc</code><span class="sig-paren">(</span><em>psd3</em>, <em>prange</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.mwc" title="Permalink to this definition">¶</a></dt>
<dd><p>plots a test case</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.plotPSDs">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">plotPSDs</code><span class="sig-paren">(</span><em>psdfile1</em>, <em>psdfile2</em>, <em>title=None</em>, <em>outfolder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.plotPSDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a PSD from a standard (12-col,1 line header) PSD file.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.plot_profile_outliers">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">plot_profile_outliers</code><span class="sig-paren">(</span><em>data</em>, <em>x</em>, <em>y</em>, <em>ldata</em>, <em>i=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.plot_profile_outliers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.plot_psd2d">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">plot_psd2d</code><span class="sig-paren">(</span><em>wdata</em>, <em>x</em>, <em>y</em>, <em>outname=None</em>, <em>wfun=None</em>, <em>vrange=None</em>, <em>frange=None</em>, <em>prange=None</em>, <em>fignum=5</em>, <em>aspect='auto'</em>, <em>ax2f=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.plot_psd2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2017/08/01
Calculates 2D PSD. If outname is provided
rms slice power is also calculated and plotted together with figure and PSD.
Set outname to empty string to plot without generating output.
use rms_power(f,p,frange=None) to calculate rms power.
fignum window where to plot, if fignnum is 0 current figure is cleared, if None new figure is created. Default to figure 5.
frange is one or a list of frequency ranges for plotting integrated rms.
If axf2 is set to boolean or array of boolean, plot slice rms for the frequencies associated to frange on second axis. frange must be set accordingly (same number of elements).</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.psd2d">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">psd2d</code><span class="sig-paren">(</span><em>data</em>, <em>x</em>, <em>y</em>, <em>wfun=None</em>, <em>norm=1</em>, <em>rmsnorm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.psd2d" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the 2d psd. return freq and psd.
doesnt work with nan.
use 2d function for psd np.fft.rfft2 for efficiency and mimics</p>
<blockquote>
<div>what done in pySurf.psd.psd</div></blockquote>
<p>norm defines the normalization, see function normPSD.
2017/01/11 broken interface from (x,y,data..),
added check to correct on the base of sizes.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.rms_power">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">rms_power</code><span class="sig-paren">(</span><em>f</em>, <em>p</em>, <em>x=None</em>, <em>frange=None</em>, <em>ax2f=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.rms_power" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.test_plotpsd2d">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">test_plotpsd2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.test_plotpsd2d" title="Permalink to this definition">¶</a></dt>
<dd><p>test of 3 panel psd2d plot, including 2d psd and slice rms.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.test_prange_mwc">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">test_prange_mwc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.test_prange_mwc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.test_prange_mwc2">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">test_prange_mwc2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.test_prange_mwc2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.test_psd2d">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">test_psd2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.test_psd2d" title="Permalink to this definition">¶</a></dt>
<dd><p>test of plotting 2dpsd alone</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.test_slicerms">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">test_slicerms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.test_slicerms" title="Permalink to this definition">¶</a></dt>
<dd><p>test plot options for slicerms</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.psd2d.xpsd2d">
<code class="descclassname">pySurf.psd2d.</code><code class="descname">xpsd2d</code><span class="sig-paren">(</span><em>wdata</em>, <em>x</em>, <em>y</em>, <em>outname=None</em>, <em>wfun=None</em>, <em>vrange=None</em>, <em>frange=None</em>, <em>prange=None</em>, <em>fignum=5</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.psd2d.xpsd2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates 2D PSD. If outname is provided
rms slice power is also calculated and plotted together with figure and PSD.
Set outname to empty string to plot without generating output.
use rms_power(f,p,frange=None) to calculate rms power.
fignum window where to plot, if fignnum is 0 current figure is cleared, if None new figure is created. Default to figure 5.</p>
</dd></dl>

</div>
<div class="section" id="module-pySurf.testSurfaces">
<span id="pysurf-testsurfaces-module"></span><h2>pySurf.testSurfaces module<a class="headerlink" href="#module-pySurf.testSurfaces" title="Permalink to this headline">¶</a></h2>
<p>Artificially generated test surfaces.</p>
<dl class="function">
<dt id="pySurf.testSurfaces.makeGaussian">
<code class="descclassname">pySurf.testSurfaces.</code><code class="descname">makeGaussian</code><span class="sig-paren">(</span><em>size</em>, <em>fwhm=3</em>, <em>center=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.testSurfaces.makeGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a square gaussian kernel.
size is the length of a side of the square
fwhm is full-width-half-maximum, which
can be thought of as an effective radius.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.testSurfaces.test_makeGaussian">
<code class="descclassname">pySurf.testSurfaces.</code><code class="descname">test_makeGaussian</code><span class="sig-paren">(</span><em>N=100</em>, <em>rnd=3.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.testSurfaces.test_makeGaussian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pySurf.tomartagiorgia">
<span id="pysurf-tomartagiorgia-module"></span><h2>pySurf.tomartagiorgia module<a class="headerlink" href="#module-pySurf.tomartagiorgia" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pySurf.tomartagiorgia.tomg">
<code class="descclassname">pySurf.tomartagiorgia.</code><code class="descname">tomg</code><span class="sig-paren">(</span><em>f</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.tomartagiorgia.tomg" title="Permalink to this definition">¶</a></dt>
<dd><p>convert points [Nx3] data to &#8216;smart&#8217; format martagiorgia.
See format specs at the end.</p>
</dd></dl>

<dl class="function">
<dt id="pySurf.tomartagiorgia.tomg_file">
<code class="descclassname">pySurf.tomartagiorgia.</code><code class="descname">tomg_file</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.tomartagiorgia.tomg_file" title="Permalink to this definition">¶</a></dt>
<dd><p>convert matrix data file to &#8216;smart&#8217; format martagiorgia.
See format specs at the end.</p>
</dd></dl>

</div>
<div class="section" id="module-pySurf">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pySurf" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pySurf package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pySurf.FEA">pySurf.FEA module</a></li>
<li><a class="reference internal" href="#module-pySurf.PointCloud">pySurf.PointCloud module</a></li>
<li><a class="reference internal" href="#module-pySurf.affine2D">pySurf.affine2D module</a></li>
<li><a class="reference internal" href="#pysurf-clip-module">pySurf.clip module</a></li>
<li><a class="reference internal" href="#module-pySurf.cmmconvert">pySurf.cmmconvert module</a></li>
<li><a class="reference internal" href="#module-pySurf.data2D">pySurf.data2D module</a></li>
<li><a class="reference internal" href="#pysurf-data2dclass-module">pySurf.data2Dclass module</a></li>
<li><a class="reference internal" href="#module-pySurf.distanceTable">pySurf.distanceTable module</a></li>
<li><a class="reference internal" href="#pysurf-fit-cylinder-module">pySurf.fit_cylinder module</a></li>
<li><a class="reference internal" href="#module-pySurf.fit_cylinder_edit">pySurf.fit_cylinder_edit module</a></li>
<li><a class="reference internal" href="#module-pySurf.instrumentReader">pySurf.instrumentReader module</a></li>
<li><a class="reference internal" href="#module-pySurf.outliers2d">pySurf.outliers2d module</a></li>
<li><a class="reference internal" href="#module-pySurf.plane_fit">pySurf.plane_fit module</a></li>
<li><a class="reference internal" href="#module-pySurf.points">pySurf.points module</a></li>
<li><a class="reference internal" href="#module-pySurf.psd2d">pySurf.psd2d module</a></li>
<li><a class="reference internal" href="#module-pySurf.testSurfaces">pySurf.testSurfaces module</a></li>
<li><a class="reference internal" href="#module-pySurf.tomartagiorgia">pySurf.tomartagiorgia module</a></li>
<li><a class="reference internal" href="#module-pySurf">Module contents</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pySurf.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Vincenzo Cotroneo vcotroneo@cfa.harvard.edu.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/pySurf.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>