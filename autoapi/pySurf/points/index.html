<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pySurf.points &mdash; pyXsurf  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/mystnb.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="pySurf.psd2d" href="../psd2d/index.html" />
    <link rel="prev" title="pySurf.plane_fit" href="../plane_fit/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> pyXsurf
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../example.html">Example usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conduct.html">Code of Conduct</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../dataIO/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataIO</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readConfig/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readConfig</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readConfig2/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readConfig2</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../test/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../test_program_path/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test_program_path</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../plotting/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plotting</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../annotations/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotations</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../astupidloop/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">astupidloop</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../test_interactive/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test_interactive</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tkmatplotlibembedded/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkmatplotlibembedded</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v1/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">v1</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v2/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">v2</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pyGeo3D/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyGeo3D</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pyProfile/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyProfile</span></code></a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../FEA/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.FEA</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../PointCloud/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.PointCloud</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../_instrument_reader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf._instrument_reader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../affine2D/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.affine2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../clip/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.clip</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../data2D/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.data2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../data2D_class/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.data2D_class</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../distanceTable/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.distanceTable</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../find_internal_rectangle/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.find_internal_rectangle</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../fit_cylinder/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.fit_cylinder</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../instrumentReader/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.instrumentReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../outliers2d/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.outliers2d</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../plane_fit/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.plane_fit</span></code></a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.points</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../psd2d/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.psd2d</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../radial/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.radial</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../roi/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.roi</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../stress_compensation/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.stress_compensation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../testSurfaces/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.testSurfaces</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../utilities/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">utilities</span></code></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyXsurf</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">API Reference</a> &raquo;</li>
          <li><a href="../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf</span></code></a> &raquo;</li>
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.points</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/autoapi/pySurf/points/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pySurf.points">
<span id="pysurf-points"></span><h1><a class="reference internal" href="#module-pySurf.points" title="pySurf.points"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pySurf.points</span></code></a><a class="headerlink" href="#module-pySurf.points" title="Permalink to this headline"></a></h1>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Permalink to this headline"></a></h2>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline"></a></h3>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.crop_points1" title="pySurf.points.crop_points1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop_points1</span></code></a>(points, xrange=None, yrange=None, zrange=None, poly=None, interactive=False)</p></td>
<td><p>crop a xyz points [Nx3], keeping only points inside xrange and yrange defined as (min,max).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.crop_points" title="pySurf.points.crop_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop_points</span></code></a>(points, xrange=None, yrange=None, zrange=None, mask=False, poly=None, interactive=False)</p></td>
<td><p>experimental version, adds option booleam to return mask. useful e.g. to clean data based on crop on deltaR</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.rotate_points" title="pySurf.points.rotate_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_points</span></code></a>(points, theta, center=(0, 0))</p></td>
<td><p>returns rotated coordinates of 2D point(s) x ([Npoints x 2]) about a center with anticlockwise angle theta in rad. If 3D points are passed, z coordinate is maintained.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.translate_points" title="pySurf.points.translate_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate_points</span></code></a>(points, offset=None)</p></td>
<td><p>returns translated coordinates. Useless routine, can be done with</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points._get_plane" title="pySurf.points._get_plane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_plane</span></code></a>(points, pars=None, xrange=None, yrange=None, zrange=None, mask=None, returnPars=False)</p></td>
<td><p>Return points of a plane defined by pars on x,y coordinates of points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.level_points" title="pySurf.points.level_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">level_points</span></code></a>(points, xrange=None, yrange=None, zrange=None, mask=None, pars=None, retall=False)</p></td>
<td><p>return the leveled points (after subtraction of best fit plane on selected points).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.points_find_hull" title="pySurf.points.points_find_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_find_hull</span></code></a>(pts)</p></td>
<td><p>return the convex hull non containing invalid (nan) points as a (np,2) array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.points_in_poly2" title="pySurf.points.points_in_poly2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_in_poly2</span></code></a>(pts, vert)</p></td>
<td><p>return a boolen array, True if point is inside a polygon,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.points_in_poly" title="pySurf.points.points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_in_poly</span></code></a>(pts, verts)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.clipStats" title="pySurf.points.clipStats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clipStats</span></code></a>(p, clip)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.points_rms" title="pySurf.points.points_rms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_rms</span></code></a>(points, xrange=None, yrange=None, zrange=None, mask=None)</p></td>
<td><p>return the rms of the selected points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.histostats" title="pySurf.points.histostats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histostats</span></code></a>(points, bins=100, log=True, *args, **kwargs)</p></td>
<td><p>Plot histogram of z. Accept arguments for plt.hist.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.matrix_to_points2" title="pySurf.points.matrix_to_points2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_to_points2</span></code></a>(mdata, x=None, y=None, xrange=None, yrange=None)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.matrix_to_points" title="pySurf.points.matrix_to_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_to_points</span></code></a>(data, xgrid, ygrid, transpose=False)</p></td>
<td><p>this assumes that the order in data (after flattening) follows the order of</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.get_points" title="pySurf.points.get_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_points</span></code></a>(filename, x=None, y=None, xrange=None, yrange=None, matrix=False, addaxis=False, scale=None, center=None, skip_header=None, delimiter=',')</p></td>
<td><p>Return a set of xyz points (N,3) from generic csv files in xyz or matrix format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.save_points" title="pySurf.points.save_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_points</span></code></a>(filename, points, xgrid=None, ygrid=None, shape=None, matrix=False, fill_value=np.nan, addaxis=True, **kwargs)</p></td>
<td><p>save points on a file. If matrix is true write in matrix form (in this case you have to</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.points_find_grid2" title="pySurf.points.points_find_grid2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_find_grid2</span></code></a>(points, result='shape', sort=None, steps=None)</p></td>
<td><p>Given points as pointcloud, do some basic guess on shape and axis orientation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.points_find_grid" title="pySurf.points.points_find_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_find_grid</span></code></a>(points, result='shape', sort=None)</p></td>
<td><p>Given points as pointcloud, do some basic guess on shape and axis orientation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.rebin_points" title="pySurf.points.rebin_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rebin_points</span></code></a>(tpoints, matrix=False, steps=None, *args, **kwargs)</p></td>
<td><p>Use <cite>stats.binned_statistic_2d</cite> to create a new surface from original points</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.resample_points" title="pySurf.points.resample_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample_points</span></code></a>(tpoints, positions)</p></td>
<td><p>resample tpoints [Npoints x 3] on the points defined in positions [Mpoints x 2], or [Mpoints x 3]</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.resample_grid" title="pySurf.points.resample_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample_grid</span></code></a>(tpoints, xgrid=None, ygrid=None, matrix=False, resample=True)</p></td>
<td><p>resample tpoints [Npoints x 3] on the grid defined by two vectors xgrid [Nx] and ygrid [Ny].</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.points_autoresample" title="pySurf.points.points_autoresample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_autoresample</span></code></a>(points, cut=0, resample=True)</p></td>
<td><p>Use points_find_grid to determine the grid for points and resample.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.extract_profile" title="pySurf.points.extract_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_profile</span></code></a>(points, xy0, xy1=None, npoints=None, along=True, plot=False)</p></td>
<td><p>extract a profile from xy0=(x0, y0) to xy1=(x1,y1).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.plot_points" title="pySurf.points.plot_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_points</span></code></a>(points, xgrid=None, ygrid=None, shape=None, units=None, resample=True, scatter=False, contours=0, bar=True, stats=True, **kwargs)</p></td>
<td><p>resample xyz points [Nx3] to a grid whose axis xgrid and ygrid are given</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.subtract_points" title="pySurf.points.subtract_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_points</span></code></a>(p1, p2, xysecond=False, resample=True)</p></td>
<td><p>Subtract second set of points after interpolation on first set coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.subtract_points2" title="pySurf.points.subtract_points2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_points2</span></code></a>(p1, p2, xySecond=False, resample=True)</p></td>
<td><p>attempt to make subtract_points faster by transposing and acting on faster slice</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.subtract_points_old" title="pySurf.points.subtract_points_old"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_points_old</span></code></a>(p1, p2, xySecond=False, resample=True)</p></td>
<td><p>Subtract second set of points after interpolation on first set coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.roicircle_points" title="pySurf.points.roicircle_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roicircle_points</span></code></a>(points, radius, missing=None, invert=False)</p></td>
<td><p>Select points inside a circle of given radius. Points outside the circle are removed</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.smooth_points" title="pySurf.points.smooth_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_points</span></code></a>(points, xywidth, xgrid=None, ygrid=None, shape=None, matrix=False)</p></td>
<td><p>resample points on a grid and perform moving average smoothin in x and y according to xywidth,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.smooth_points2" title="pySurf.points.smooth_points2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_points2</span></code></a>(points, xywidth, xgrid=None, ygrid=None, shape=None)</p></td>
<td><p>NOT WORKING shape in format (nx,ny) as convention in points, opposite of python.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline"></a></h3>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.verbose" title="pySurf.points.verbose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">verbose</span></code></a></p></td>
<td><p>Module containing functions acting on a point cloud. With the intention</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pySurf.points.method" title="pySurf.points.method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">method</span></code></a></p></td>
<td><p>2014/03/17 moved here all routines from EA2019_align and from OP1S07_align.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pySurf.points.pts" title="pySurf.points.pts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pts</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt class="sig sig-object py" id="pySurf.points.verbose">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="pre">=</span> <span class="pre">False</span></em><a class="headerlink" href="#pySurf.points.verbose" title="Permalink to this definition"></a></dt>
<dd><p>Module containing functions acting on a point cloud. With the intention
of creating a class. Points are in format (Npoints,Ndim).
Note also that shape, when used (mostly is just a visual parameter for plots), is in format (nx,ny), that is opposite to python convention.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="pySurf.points.method">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">method</span></span><em class="property"><span class="w"> </span><span class="pre">=</span> <span class="pre">linear</span></em><a class="headerlink" href="#pySurf.points.method" title="Permalink to this definition"></a></dt>
<dd><p>2014/03/17 moved here all routines from EA2019_align and from OP1S07_align.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.crop_points1">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">crop_points1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interactive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.crop_points1" title="Permalink to this definition"></a></dt>
<dd><p>crop a xyz points [Nx3], keeping only points inside xrange and yrange defined as (min,max).
Interactive allows to set a region by zooming and/or a polygon by point and click
(order of vertex matters).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.crop_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">crop_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interactive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.crop_points" title="Permalink to this definition"></a></dt>
<dd><p>experimental version, adds option booleam to return mask. useful e.g. to clean data based on crop on deltaR</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.rotate_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">rotate_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.rotate_points" title="Permalink to this definition"></a></dt>
<dd><p>returns rotated coordinates of 2D point(s) x ([Npoints x 2]) about a center with anticlockwise angle theta in rad. If 3D points are passed, z coordinate is maintained.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.translate_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">translate_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.translate_points" title="Permalink to this definition"></a></dt>
<dd><p>returns translated coordinates. Useless routine, can be done with
a simple sum points+offset</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points._get_plane">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">_get_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnPars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points._get_plane" title="Permalink to this definition"></a></dt>
<dd><p>Return points of a plane defined by pars on x,y coordinates of points.
pars is a 3 elements vector [A,B,C] according to Ax + By + C = z.
if pars is None, plane is calculated by best fit on selected points and two elements are returned:
the points of the best fit plane and its parameters A,B,C. The points are calculated on all
points positions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.level_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">level_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retall</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.level_points" title="Permalink to this definition"></a></dt>
<dd><p>return the leveled points (after subtraction of best fit plane on selected points).
If pars is provided as 3 elements vector is intended as plane coefficients and fit is not performed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.points_find_hull">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">points_find_hull</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_find_hull" title="Permalink to this definition"></a></dt>
<dd><p>return the convex hull non containing invalid (nan) points as a (np,2) array.
hull=points_find_hull(pts)
plt.plot(hull[:,0], hull[:,1], ‘r–’, lw=2).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.points_in_poly2">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">points_in_poly2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vert</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_in_poly2" title="Permalink to this definition"></a></dt>
<dd><p>return a boolen array, True if point is inside a polygon,
given its vertices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.points_in_poly">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">points_in_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_in_poly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.clipStats">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">clipStats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.clipStats" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.points_rms">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">points_rms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_rms" title="Permalink to this definition"></a></dt>
<dd><p>return the rms of the selected points.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.histostats">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">histostats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.histostats" title="Permalink to this definition"></a></dt>
<dd><p>Plot histogram of z. Accept arguments for plt.hist.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.matrix_to_points2">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">matrix_to_points2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mdata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.matrix_to_points2" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.matrix_to_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">matrix_to_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xgrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ygrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transpose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.matrix_to_points" title="Permalink to this definition"></a></dt>
<dd><p>this assumes that the order in data (after flattening) follows the order of
x and y in meshgrid. If not (vertical direction first), set flag transpose.
Not tested on arrays with different x and y, potentially a mess.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.get_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">get_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addaxis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.get_points" title="Permalink to this definition"></a></dt>
<dd><p>Return a set of xyz points (N,3) from generic csv files in xyz or matrix format.</p>
<p>For example for nanovea saved txt (matrix=False) or gwyddion saved matrix (matrix=True, xrange, yrange must be defined).</p>
<p><cite>x</cite> and <cite>y</cite> added 2018/02/17 make sense only for data in matrix format,
allowing to ovveride or set values for the x and y axis and apply
modifications that would not be straightforward on the returned value in
<cite>points</cite> format.</p>
<p>input x and y can be None or empty object (calculate from data size), M-element array (must fit data size) or range (2-el). If the last two cases (when appropriate axis are passed), they are always used and get priority on what is read from file, be careful to omit them unless you want to alter data.</p>
<p>This way I can e.g. open a matrix file and return points with a modified x y grid. Setting x or y to an empty object rather than to None discards axis from file and use grid indices.</p>
<dl class="simple">
<dt>addaxis: (if matrix is set) can be set to True to read values for axis in first row and column</dt><dd><p>(e.g. if points were saved with default addaxis=True in save_data.</p>
</dd>
</dl>
<p>A single axis can be extracted if addaxis is set to string ‘x’, ‘y’.
<cite>True</cite> is equivalent to set to ‘xy’ (added 2020/06/18).</p>
<dl class="simple">
<dt>A complete description of the possible options is:</dt><dd><p>read and use from file: addaxis=True, x= None
read and discard from file, use passed: addaxis=True, x=np.array
read and discard from file, use calculated: addaxis=True, x=[]
don’t read from file, use passed: addaxis=False, x=np.array
don’t read from file, use calculated: addaxis=False, x=None|[]</p>
</dd>
<dt>center is the position of the center of the image in final coordinates (changed on 2016/08/10, it was ‘(before any scaling or rotation) in absolute coordinates.’) If None coordinates are left unchanged.</dt><dd><p>Set to (0,0) to center the coordinate system to the data.</p>
</dd>
<dt>addaxis (if matrix is set) can be set to read values for axis in first row and column</dt><dd><p>(e.g. if points were saved with default addaxis=True in save_points.</p>
</dd>
</dl>
<p>2020/06/18 changes to logic in reading axis with matrix option, it was failing when x and y not set. Added possibility of individual <cite>addAxis</cite>
TODO: reduce overlapping with <cite>data2D.data_from_txt</cite>.
2018/02/17 reintroduced xrange even if discorauged. implemented x and y (unused as well) to axis, range
or indices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.save_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">save_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xgrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ygrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addaxis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.save_points" title="Permalink to this definition"></a></dt>
<dd><p>save points on a file. If matrix is true write in matrix form (in this case you have to
provide the values for axis). Otherwise write as points in columns.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.points_find_grid2">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">points_find_grid2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'shape'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_find_grid2" title="Permalink to this definition"></a></dt>
<dd><p>Given points as pointcloud, do some basic guess on shape and axis orientation
of the grid.
Works for raster points, even irregular and non rectangular, but not for scatter
(step is estimated from the first two elements, it fails if elements are not sorted,
points can be sorted xy or yx to avoid failure, like (xysort):</p>
<blockquote>
<div><p>a = a[a[:,1].argsort()]
a = a[a[:,0].argsort(kind=’mergesort’)] #stable sort.</p>
</div></blockquote>
<p>Return a tuple (fastind,result), fastind is 1 for y and 0 for x,
result can be ‘shape’, ‘step’  or ‘grid’.
step can be provided as scalar or 2d vector to enforce step size</p>
<dl class="simple">
<dt>sort can be None, ‘xy’, ‘yx’ (respectively try to guess, x or y faster)</dt><dd><p>or ‘none’ (apply stable sort xy before calculating grid).</p>
</dd>
</dl>
<p>This second version, works well in well-behaved cases, for more complex situations,
better to check results (see critical cases below).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.points_find_grid">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">points_find_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'shape'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_find_grid" title="Permalink to this definition"></a></dt>
<dd><p>Given points as pointcloud, do some basic guess on shape and axis orientation
of the grid. Not many checks in this first version, you need to verify results.
Works for raster points, even irregular and non rectangular, but not for scatter (step is estimated from the first two
elements, it fails if elements are not sorted, points can be
sorted xy or yx to avoid failure, like (xysort):</p>
<blockquote>
<div><p>a = a[a[:,1].argsort()]
a = a[a[:,0].argsort(kind=’mergesort’)] #stable sort.</p>
</div></blockquote>
<p>Return a tuple (fastind,result), fastind is 1 for y and 0 for x,
result can be ‘shape’, ‘step’  or ‘grid’.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.rebin_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">rebin_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.rebin_points" title="Permalink to this definition"></a></dt>
<dd><p>Use <cite>stats.binned_statistic_2d</cite> to create a new surface from original points
divided in bins centered on xy of final points. Points in a bin can be averaged
(default) or binned statistics options can be used to obtain result values.</p>
<p>It is theoretically the best way to create a surface on a grid with minimal loss of information,
however it can be tricky, both for estimating errors (or values on empty bins) and for
transformations (e.g. crop ).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.resample_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">resample_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.resample_points" title="Permalink to this definition"></a></dt>
<dd><p>resample tpoints [Npoints x 3] on the points defined in positions [Mpoints x 2], or [Mpoints x 3]
(in this case 3rd column is ignored).
Return a [Nx x Ny , 3] vector of points. To get a (plottable) matrix of data use:
plt.imshow(rpoints[:,2].reshape(xgrid.size,ygrid.size)).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.resample_grid">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">resample_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xgrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ygrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.resample_grid" title="Permalink to this definition"></a></dt>
<dd><p>resample tpoints [Npoints x 3] on the grid defined by two vectors xgrid [Nx] and ygrid [Ny].
Return a [Nx * Ny , 3] vector of points, sorted in standard python order
(x changes faster) or a matrix if matrix=True. if resample is set to False
only x and y are changed and values are not touched (must maintain number of points).
matrix=True–&gt;points to matrix
p=resample_grid(p) #straighten the grid of p changing data as little as possible
matrix=False,resample=False-&gt; Convert from matrix to points without resampling if matrix input, useless if input is points (do two opposite operations that should cancel each other).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.points_autoresample">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">points_autoresample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.points_autoresample" title="Permalink to this definition"></a></dt>
<dd><p>Use points_find_grid to determine the grid for points and resample.
It should give minimal alteration of points when close to grid.
This routine returns data,x,y
Same result can be obtained by calling
resample_grid (without providing x and y)
AND points_find_grid to determine x and y.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.extract_profile">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">extract_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xy0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xy1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">along</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.extract_profile" title="Permalink to this definition"></a></dt>
<dd><p>extract a profile from xy0=(x0, y0) to xy1=(x1,y1).
Return a couple of vectors x, y, z. The number of points can be set, otherwise is set
accordingly to the longest profile dimension.
If <cite>along</cite> is set (default), a two-dim x-z profile is returned with x distance
along the profile from xy0.
If called without second argument, extract point.
#TODO, can be made faster by cropping data around profile.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.plot_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">plot_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xgrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ygrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.plot_points" title="Permalink to this definition"></a></dt>
<dd><p>resample xyz points [Nx3] to a grid whose axis xgrid and ygrid are given
and plot it. If resample is set to False x and y positions are considered only for range,
but they are not used to position the z values (it works if x and y are on an exact unrotated grid,
resampling is slower, but exact).
shape is in format (nx,ny) that is opposite to python convention.
contours is contour spacing.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.subtract_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">subtract_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xysecond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.subtract_points" title="Permalink to this definition"></a></dt>
<dd><p>Subtract second set of points after interpolation on first set coordinates.
If xySecond is set to True data are interpolate on xy of p2 and then subtracted.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.subtract_points2">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">subtract_points2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xySecond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.subtract_points2" title="Permalink to this definition"></a></dt>
<dd><p>attempt to make subtract_points faster by transposing and acting on faster slice</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.subtract_points_old">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">subtract_points_old</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xySecond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.subtract_points_old" title="Permalink to this definition"></a></dt>
<dd><p>Subtract second set of points after interpolation on first set coordinates.
If xySecond is set to True data are interpolate on xy of p2 and then subtracted.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.roicircle_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">roicircle_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.roicircle_points" title="Permalink to this definition"></a></dt>
<dd><p>Select points inside a circle of given radius. Points outside the circle are removed
or replaced by a missing value.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.smooth_points">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">smooth_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xywidth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xgrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ygrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.smooth_points" title="Permalink to this definition"></a></dt>
<dd><p>resample points on a grid and perform moving average smoothin in x and y according to xywidth,
if one component is None smoothing in that direction is not performed.
Return points in usual coordinates, unless matrix flag is set.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pySurf.points.smooth_points2">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">smooth_points2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xywidth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xgrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ygrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pySurf.points.smooth_points2" title="Permalink to this definition"></a></dt>
<dd><p>NOT WORKING shape in format (nx,ny) as convention in points, opposite of python.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="pySurf.points.pts">
<span class="sig-prename descclassname"><span class="pre">pySurf.points.</span></span><span class="sig-name descname"><span class="pre">pts</span></span><a class="headerlink" href="#pySurf.points.pts" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../plane_fit/index.html" class="btn btn-neutral float-left" title="pySurf.plane_fit" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../psd2d/index.html" class="btn btn-neutral float-right" title="pySurf.psd2d" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, vincenzo cotroneo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>